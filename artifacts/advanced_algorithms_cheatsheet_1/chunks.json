[
  {
    "chunk_id": "D1-C1",
    "doc": "advanced_algorithms_cheatsheet_1.pdf",
    "text": "Advanced LeetCode/Google Algorithms Cheat Sheet\nTime/space complexities included where helpful. Python-first, interview-ready.\nKahn's Algorithm (Topological Sort + Cycle Detection)\nfrom collections import deque, defaultdict\ndef topo_sort_kahn(n, edges):\n # O(V + E) time, O(V + E) space\n adj = defaultdict(list)\n indeg = [0]*n\n for u, v in edges:\n adj[u].append(v); indeg[v] += 1\n q = deque(i for i in range(n) if indeg[i] == 0)\n order = []\n while q:\n u = q.popleft()\n order.append(u)\n for v in adj[u]:\n indeg[v] -= 1\n if indeg[v] == 0:\n q.append(v)\n return order if len(order) == n else [] # empty => cycle\nZ-Algorithm (Pattern Matching)\ndef z_array(s: str):\n # O(n) time, O(n) space\n n = len(s)\n Z = [0]*n\n l = r = 0\n for i in range(1, n):\n if i <= r:\n Z[i] = min(r - i + 1, Z[i - l])\n while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:\n Z[i] += 1\n if i + Z[i] - 1 > r:\n l, r = i, i + Z[i] - 1\n Z[0] = n\n return Z\ndef z_search(text: str, pat: str):\n t = pat + '$' + text\n Z = z_array(t)\n m = len(pat)\n return [i - (m+1) for i in range(m+1, len(t)) if Z[i] == m]\nKMP (Knuth–Morris–Pratt) String Search\ndef kmp_lps(pat: str):\n # O(m) time\n lps = [0]*len(pat)\n j = 0\n for i in range(1, len(pat)):\n while j and pat[i] != pat[j]:\n j = lps[j-1]\n if pat[i] == pat[j]:\n j += 1\n lps[i] = j\n\n return lps\ndef kmp_search(text: str, pat: str):\n # O(n) time overall\n if not pat: return list(range(len(text)+1))\n lps = kmp_lps(pat)\n i = j = 0\n res = []\n while i < len(text):\n if text[i] == pat[j]:\n i += 1; j += 1\n if j == len(pat):\n res.append(i - j)\n j = lps[j-1]\n else:\n if j: j = lps[j-1]\n else: i += 1\n return res\nManacher's Algorithm (Longest Palindromic Substring)\ndef manacher_longest_palindrome(s: str) -> int:\n # O(n) time, O(n) space\n t = '^#' + '#'"
  },
  {
    "chunk_id": "D1-C2",
    "doc": "advanced_algorithms_cheatsheet_1.pdf",
    "text": ".join(s) + '#$'\n n = len(t)\n P = [0]*n\n C = R = 0\n for i in range(1, n-1):\n mirror = 2*C - i\n if i < R:\n P[i] = min(R - i, P[mirror])\n while t[i + P[i] + 1] == t[i - P[i] - 1]:\n P[i] += 1\n if i + P[i] > R:\n C, R = i, i + P[i]\n return max(P)\nDisjoint Set Union (Union-Find)\nclass DSU:\n # near O(α(n)) amortized per op\n def __init__(self, n):\n self.p = list(range(n))\n self.r = [0]*n\n def find(self, x):\n while x != self.p[x]:\n self.p[x] = self.p[self.p[x]]\n x = self.p[x]\n return x\n def union(self, a, b):\n ra, rb = self.find(a), self.find(b)\n if ra == rb: return False\n if self.r[ra] < self.r[rb]:\n self.p[ra] = rb\n elif self.r[ra] > self.r[rb]:\n self.p[rb] = ra\n else:\n self.p[rb] = ra\n self.r[ra] += 1\n return True\nDijkstra & 0-1 BFS\n\nimport heapq\nfrom collections import defaultdict, deque\ndef dijkstra(n, edges, src):\n # O((V+E) log V)\n adj = defaultdict(list)\n for u, v, w in edges:\n adj[u].append((v, w))\n dist = [float('inf')]*n\n dist[src] = 0\n pq = [(0, src)]\n while pq:\n d, u = heapq.heappop(pq)\n if d != dist[u]: continue\n for v, w in adj[u]:\n nd = d + w\n if nd < dist[v]:\n dist[v] = nd\n heapq.heappush(pq, (nd, v))\n return dist\ndef zero_one_bfs(n, edges, src):\n # O(V + E) for weights in {0,1}\n adj = defaultdict(list)\n for u, v, w in edges:\n adj[u].append((v, w))\n dist = [float('inf')]*n\n dist[src] = 0\n dq = deque([src])\n while dq:\n u = dq.popleft()\n for v, w in adj[u]:\n if dist[u] + w < dist[v]:\n dist[v] = dist[u] + w\n if w == 0: dq.appendleft(v)\n else: dq.append(v)\n return dist\nTarjan's Algorithm (Bridges / Critical Connections)\nfrom collections import defaultdict\ndef bridges(n, edges):\n # O(V + E)\n adj = defaultdict(list)\n for u, v in edges:\n adj[u].append(v); adj[v]"
  },
  {
    "chunk_id": "D1-C3",
    "doc": "advanced_algorithms_cheatsheet_1.pdf",
    "text": ".append(u)\n disc = [-1]*n\n low = [-1]*n\n time = 0\n res = []\n def dfs(u, parent):\n nonlocal time\n disc[u] = low[u] = time; time += 1\n for v in adj[u]:\n if disc[v] == -1:\n dfs(v, u)\n low[u] = min(low[u], low[v])\n if low[v] > disc[u]:\n res.append((u, v))\n elif v != parent:\n low[u] = min(low[u], disc[v])\n for i in range(n):\n if disc[i] == -1:\n dfs(i, -1)\n return res\n\nMonotonic Stack (Largest Rectangle in Histogram)\ndef largest_rectangle_area(heights):\n # O(n) time, O(n) space\n heights.append(0)\n st = []\n best = 0\n for i, h in enumerate(heights):\n while st and heights[st[-1]] > h:\n H = heights[st.pop()]\n L = st[-1] if st else -1\n best = max(best, H * (i - L - 1))\n st.append(i)\n heights.pop()\n return best\nSegment Tree (Range Sum / Point Update)\nclass SegTree:\n # O(log n) per update/query, O(n) space\n def __init__(self, nums):\n n = len(nums); self.n = 1\n while self.n < n: self.n <<= 1\n self.t = [0]*(2*self.n)\n for i, v in enumerate(nums):\n self.t[self.n + i] = v\n for i in range(self.n-1, 0, -1):\n self.t[i] = self.t[i<<1] + self.t[i<<1|1]\n def update(self, i, val):\n i += self.n\n self.t[i] = val\n i >>= 1\n while i:\n self.t[i] = self.t[i<<1] + self.t[i<<1|1]\n i >>= 1\n def query(self, l, r): # [l, r)\n res = 0\n l += self.n; r += self.n\n while l < r:\n if l & 1: res += self.t[l]; l += 1\n if r & 1: r -= 1; res += self.t[r]\n l >>= 1; r >>= 1\n return res\nFenwick Tree / Binary Indexed Tree (Prefix Sums)\nclass Fenwick:\n # O(log n) per op, O(n) space\n def __init__(self, n):\n self.n = n\n self.bit = [0]*(n+1)\n def add(self, i, delta): # 0-indexed\n i += 1\n while i <= self.n:\n self.bit[i] += delta\n i += i & -i\n def sum(self, i): # prefix sum [0..i], 0-indexed\n i += 1\n s = 0\n while i > 0:\n s += self.bit[i]\n i -= i & -i\n return s\n\n def range_sum(self, l, r):\n return self.sum(r) - self"
  },
  {
    "chunk_id": "D1-C4",
    "doc": "advanced_algorithms_cheatsheet_1.pdf",
    "text": ".sum(l-1)\nTrie (Prefix Tree)\nclass TrieNode:\n __slots__ = (\"children\", \"end\")\n def __init__(self):\n self.children = {}\n self.end = False\nclass Trie:\n # insert/search/prefix in O(L), space O(total chars)\n def __init__(self):\n self.root = TrieNode()\n def insert(self, word: str) -> None:\n cur = self.root\n for ch in word:\n if ch not in cur.children:\n cur.children[ch] = TrieNode()\n cur = cur.children[ch]\n cur.end = True\n def search(self, word: str) -> bool:\n cur = self.root\n for ch in word:\n if ch not in cur.children:\n return False\n cur = cur.children[ch]\n return cur.end\n def startsWith(self, prefix: str) -> bool:\n cur = self.root\n for ch in prefix:\n if ch not in cur.children:\n return False\n cur = cur.children[ch]\n return True"
  }
]